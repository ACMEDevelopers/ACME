% generateM generates the matlab wrapper for the mex files which simplifies the calling of the mex simulation file
%
% USAGE:
% ======
% generateC( modelname, modelstruct)
% 
% INPUTS:
% =======
% modelname ... specifies the name of the model which will be later used for the naming of the simualation file
% modelstruct ... is the struct generated by parseModel

function lw_generateM( filename, struct )
    %GENERATEM Summary of this function goes here
    %   Detailed explanation goes here
    
    if(~ispc)
        odewrap_path = strrep(which('lw_compileC.m'),'lw_compileC.m','');
    else
        odewrap_path = strrep(which('lw_compileC.m'),'lw_compileC.m','');
    end
    
    nx = length(struct.sym.x);
    ny = length(struct.sym.y);
    np = length(struct.sym.p);
    nk = length(struct.sym.k);
    nu = length(struct.sym.u);
    nr = length(struct.sym.root);
    
    %% FSA
    
    fid = fopen([odewrap_path 'models/' filename '/llh_' filename '.m'],'w');
    fprintf(fid,['%% simulate_' filename '.m is the matlab interface to the cvodes mex\n'...
    '%%   which simulates the ordinary differential equation and respective\n'...
    '%%   sensitivities according to user specifications.\n'...
    '%%\n'...
    '%% USAGE:\n'...
    '%% ======\n'...
    '%% [...] = llh_' filename '(tout,theta,kappa,data,options)\n'...
    '%% [sol] = llh_' filename '(...)\n'...
    '%%\n'...
    '%% INPUTS:\n'...
    '%% =======\n'...
    '%% tout ... 1 dimensional vector of timepoints at which a solution to the ODE is desired\n'...
    '%% theta ... 1 dimensional parameter vector of parameters for which sensitivities are desired.\n'...
    '%%           this corresponds to the specification in model.sym.p\n'...
    '%% kappa ... 1 dimensional parameter vector of parameters for which sensitivities are not desired.\n'...
    '%%           this corresponds to the specification in model.sym.k\n'...
    '%% data ... struct containing the following fields. Can have the following fields '...
    '%%     Y ... 2 dimensional matrix containing data.\n'...
    '%%           columns must correspond to observables and rows to time-points\n'...
    '%%     Sigma_Y ... 2 dimensional matrix containing standard deviation of data.\n'...
    '%%           columns must correspond to observables and rows to time-points\n'...
    '%%     T ... (optional) 2 dimensional matrix containing events.\n'...
    '%%           columns must correspond to event-types and rows to possible event-times\n'...
    '%%     Sigma_T ... (optional) 2 dimensional matrix containing standard deviation of events.\n'...
    '%%           columns must correspond to event-types and rows to possible event-times\n'...
    '%% options ... additional options to pass to the cvodes solver. Refer to the cvodes guide for more documentation.\n'...
    '%%    .cvodes_atol ... absolute tolerance for the solver. default is specified in the user-provided syms function.\n'...
    '%%    .cvodes_rtol ... relative tolerance for the solver. default is specified in the user-provided syms function.\n'...
    '%%    .maxsteps    ... maximal number of integration steps. default is specified in the user-provided syms function.\n'...
    '%%    .tstart    ... start of integration. for all timepoints before this, values will be set to initial value.\n'...
    '%%    .options_cvode.sens_ind ... 1 dimensional vector of indexes for which sensitivities must be computed.\n'...
    '%%           default value is 1:length(theta).\n'...
    '%%    .lmm    ... linear multistep method for forward problem.\n'...
    '%%        1: Adams-Bashford\n'...
    '%%        2: BDF (DEFAULT)\n'...
    '%%    .iter    ... iteration method for linear multistep.\n'...
    '%%        1: Functional\n'...
    '%%        2: Newton (DEFAULT)\n'...
    '%%    .linsol   ... linear solver module.\n'...
    '%%        direct solvers:\n'...
    '%%        1: Dense (DEFAULT)\n'...
    '%%        2: Band (not implented)\n'...
    '%%        3: LAPACK Dense (not implented)\n'...
    '%%        4: LAPACK Band  (not implented)\n'...
    '%%        5: Diag (not implented)\n'...
    '%%        implicit krylov solvers:\n'...
    '%%        6: SPGMR\n'...
    '%%        7: SPBCG\n'...
    '%%        8: SPTFQMR\n'...
    '%%    .stldet   ... flag for stability limit detection. this should be turned on for stiff problems.\n'...
    '%%        0: OFF\n'...
    '%%        1: ON (DEFAULT)\n'...
    '%%    .qPositiveX   ... vector of 0 or 1 of same dimension as state vector. 1 enforces positivity of states.\n'...
    '%%    .sensi_meth   ... method for sensitivity computation.\n'...
    '%%        1: Forward Sensitivity Analysis (DEFAULT)\n'...
    '%%        2: Adjoint Sensitivity Analysis\n'...
    '%%    .ism   ... only available for sensi_meth == 1. Method for computation of forward sensitivities.\n'...
    '%%        1: Simultaneous (DEFAULT)\n'...
    '%%        2: Staggered\n'...
    '%%        3: Staggered1\n'...
    '%%    .Nd   ... only available for sensi_meth == 2. Number of Interpolation nodes for forward solution. \n'...
    '%%              Default is 1000. \n'...
    '%%    .interpType   ... only available for sensi_meth == 2. Interpolation method for forward solution.\n'...
    '%%        1: Hermite (DEFAULT)\n'...
    '%%        2: Polynomial\n'...
    '%%    .lmmB   ... only available for sensi_meth == 2. linear multistep method for backward problem.\n'...
    '%%        1: Adams-Bashford\n'...
    '%%        2: BDF (DEFAULT)\n'...
    '%%    .iterB   ... only available for sensi_meth == 2. iteration method for linear multistep.\n'...
    '%%        1: Functional\n'...
    '%%        2: Newton (DEFAULT)\n'...
    '%%    .data_model   ... noise model for data.\n'...
    '%%        1: Normal (DEFAULT)\n'...
    '%%        2: Lognormal \n'...
    '%%    .event_model   ... noise model for events.\n'...
    '%%        1: Normal (DEFAULT)\n'...
    '%%        2: Lognormal \n'...
    '%%\n'...
    '%% Outputs:\n'...
    '%% ========\n'...
    '%% sol.status ... flag for status of integration. generally status<0 for failed integration\n'...
    '%% sol.tout ... vector at which the solution was computed\n'...
    '%% sol.llh ... likelihood value\n'...
    '%% sol.sllh ... gradient of likelihood\n'...
    '%% sol.s2llh ... hessian of likelihood\n'...
    '%% sol.x ... time-resolved state vector\n'...
    '%% sol.y ... time-resolved output vector\n'...
    '%% sol.xdot time-resolved right-hand side of differential equation\n'...
    '%% sol.rootval value of root at end of simulation time\n'...
    '%% sol.root time of events\n'...
    ]);
    fprintf(fid,['function sol = llh_' filename '(varargin)\n\n']);
    fprintf(fid,['%% DO NOT CHANGE ANYTHING IN THIS FILE UNLESS YOU ARE VERY SURE ABOUT WHAT YOU ARE DOING\n']);
    fprintf(fid,['%% MANUAL CHANGES TO THIS FILE CAN RESULT IN WRONG SOLUTIONS AND CRASHING OF MATLAB\n']);
    fprintf(fid,['if(nargin<2)\n']);
    fprintf(fid,['    error(''Not enough input arguments.'');\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['    tout=varargin{1};\n']);
    fprintf(fid,['    phi=varargin{2};\n']);
    fprintf(fid,['end\n']);
    
    fprintf(fid,['if(nargin>=3)\n']);
    fprintf(fid,['    kappa=varargin{3};\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['    kappa=[];\n']);
    fprintf(fid,['end\n']);
    
    fprintf(fid,['if(nargin>=4)\n']);
    fprintf(fid,['    data=varargin{4};\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['    data=[];\n']);
    fprintf(fid,['end\n']);
    
    fprintf(fid,['if(nargin>=5)\n']);
    fprintf(fid,['    if(isfield(varargin{5},''sens_ind''))\n']);
    fprintf(fid,['        options_cvode.sens_ind=varargin{5}.sens_ind;\n']);
    fprintf(fid,['    else\n']);
    fprintf(fid,['        options_cvode.sens_ind = 1:' num2str(np) ';\n']);
    fprintf(fid,['    end\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['    options_cvode.sens_ind = 1:' num2str(np) ';\n']);
    fprintf(fid,['end\n']);
    
    if(isfield(struct,'param'))
        switch(struct.param)
            case 'log'
                fprintf(fid,'theta = exp(phi(:));\n\n');
            case 'log10'
                fprintf(fid,'theta = 10.^(phi(:));\n\n');
            case 'lin'
                fprintf(fid,'theta = phi(:);\n\n');
            otherwise
                disp('No valid parametrisation chosen! Valid options are "log","log10" and "lin". Using linear parametrisation (default)!')
                fprintf(fid,'theta = phi(:);\n\n');
        end
    else
        disp('No parametrisation chosen! Using linear parametrisation (default)!')
        fprintf(fid,'theta = phi(:);\n\n');
    end
    fprintf(fid,'try\n');
    fprintf(fid,'    if(varargin{5}.speedup)\n');
    fprintf(fid,'        persistent old_theta old_tout old_kappa old_nargout\n');
    fprintf(fid,'        persistent old_status old_t old_x old_y old_sx old_sy old_sol\n');
    fprintf(fid,'    end\n');
    fprintf(fid,'catch\n');
    fprintf(fid,'end\n');
    fprintf(fid,'\n');
    if(nk==0)
        fprintf(fid,'if(nargin==2)\n');
        fprintf(fid,'    kappa = [];\n');
        fprintf(fid,'end\n');
    end
    
    fprintf(fid,['options_cvode.cvodes_atol = ' num2str(struct.atol) ';\n']);
    fprintf(fid,['options_cvode.cvodes_rtol = ' num2str(struct.atol) ';\n']);
    fprintf(fid,['options_cvode.cvodes_maxsteps = ' num2str(struct.maxsteps) ';\n']);
    
    fprintf(fid,['options_cvode.nx = ' num2str(nx) '; %% MUST NOT CHANGE THIS VALUE\n']);
    fprintf(fid,['options_cvode.ny = ' num2str(ny) '; %% MUST NOT CHANGE THIS VALUE\n']);
    fprintf(fid,['options_cvode.nr = ' num2str(nr) '; %% MUST NOT CHANGE THIS VALUE\n']);
    fprintf(fid,['options_cvode.np = length(options_cvode.sens_ind); %% MUST NOT CHANGE THIS VALUE\n']);
    fprintf(fid,['options_cvode.tstart = ' num2str(struct.t0) ';\n']);
    fprintf(fid,['%solver;\n']);
    fprintf(fid,['LW_DENSE       =1;\n']);
    fprintf(fid,['LW_BAND        =2;\n']);
    fprintf(fid,['LW_LAPACKDENSE =3;\n']);
    fprintf(fid,['LW_LAPACKBAND  =4;\n']);
    fprintf(fid,['LW_DIAG        =5;\n']);
    fprintf(fid,['LW_SPGMR       =6;\n']);
    fprintf(fid,['LW_SPBCG       =7;\n']);
    fprintf(fid,['LW_SPTFQMR     =8;\n']);
    fprintf(fid,['%sens_meth;\n']);
    fprintf(fid,['LW_FSA =1;\n']);
    fprintf(fid,['LW_ASA =2;\n']);
    fprintf(fid,['%lmm;\n']);
    fprintf(fid,['CV_ADAMS =1;\n']);
    fprintf(fid,['CV_BDF =2;\n']);
    fprintf(fid,['%interp;\n']);
    fprintf(fid,['CV_HERMITE =1;\n']);
    fprintf(fid,['CV_POLYNOMIAL =2;\n']);
    fprintf(fid,['%ism;\n']);
    fprintf(fid,['CV_SIMULTANEOUS =1;\n']);
    fprintf(fid,['CV_STAGGERED =2;\n']);
    fprintf(fid,['CV_STAGGERED1 =3;\n']);
    fprintf(fid,['%iter;\n']);
    fprintf(fid,['CV_FUNCTIONAL=1;\n']);
    fprintf(fid,['CV_NEWTON =2;\n\n']);
    fprintf(fid,['%bool;\n']);
    fprintf(fid,['LW_TRUE=1;\n']);
    fprintf(fid,['LW_FALSE=0;\n\n']);
    fprintf(fid,['%;\n']);
    fprintf(fid,['LW_NORMAL=1;\n']);
    fprintf(fid,['LW_LOGNORMAL=2;\n\n']);
    fprintf(fid,['options_cvode.lmm = CV_BDF;\n']);
    fprintf(fid,['options_cvode.iter = CV_NEWTON;\n']);
    fprintf(fid,['options_cvode.linsol = LW_DENSE;\n']);
    fprintf(fid,['options_cvode.stldet = LW_TRUE;\n']);
    fprintf(fid,['options_cvode.Nd = 1000;\n']);
    fprintf(fid,['options_cvode.interpType = CV_HERMITE;\n']);
    fprintf(fid,['options_cvode.lmmB = CV_BDF;\n']);
    fprintf(fid,['options_cvode.iterB = CV_NEWTON;\n']);
    fprintf(fid,['options_cvode.ism = CV_SIMULTANEOUS;\n']);
    fprintf(fid,['options_cvode.sensi_meth = LW_FSA;\n\n']);
    fprintf(fid,['if(isfield(data,''T''))\n']);
    fprintf(fid,['    options_cvode.nmaxroot = size(data.T,1);\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['    data.T = NaN(1,0);\n']);
    fprintf(fid,['    data.Sigma_T = NaN(1,0);\n']);
    fprintf(fid,['    options_cvode.nmaxroot = 1;\n\n']);
    fprintf(fid,['end\n']);
    fprintf(fid,['options_cvode.ubw = ' num2str(struct.ubw) ';\n\n']);
    fprintf(fid,['options_cvode.lbw = ' num2str(struct.lbw)  ';\n\n']);
    fprintf(fid,['options_cvode.data_model = 1;\n\n']);
    fprintf(fid,['options_cvode.event_model = 1;\n\n']);
    fprintf(fid,['options_cvode.qPositiveX = zeros(length(tout),' num2str(nx) ');\n']);

    fprintf(fid,['\n']);
    
    fprintf(fid,'try\n');
    fprintf(fid,'    if(all([all(tout==old_tout),all(theta==old_theta),all(kappa==old_kappa),nargout<=old_nargout,varargin{5}.speedup]))\n');
    fprintf(fid,'        sol.status = old_status;\n');
    fprintf(fid,'        sol.t = old_t;\n');
    fprintf(fid,'        sol.x = old_x;\n');
    fprintf(fid,'        sol.y = old_y;\n');
    fprintf(fid,'        if(sensi>0)\n');
    fprintf(fid,'            sol.sx = old_sx;\n');
    fprintf(fid,'            sol.sy = old_sy;\n');
    fprintf(fid,'        end\n');
    fprintf(fid,'        return;\n');
    fprintf(fid,'    end\n');
    fprintf(fid,'catch\n');
    fprintf(fid,'end\n');
    fprintf(fid,'\n');

    fprintf(fid,['sol.status = 0;\n']);
    fprintf(fid,['sol.llh = 0;\n']);
    fprintf(fid,['sol.t = tout;\n']);
    fprintf(fid,['sol.x = zeros(length(tout),' num2str(nx) ');\n']);
    fprintf(fid,['sol.y = zeros(length(tout),' num2str(ny) ');\n']);
    fprintf(fid,['sol.xdot = zeros(length(tout),' num2str(nx) ');\n']);
    fprintf(fid,['sol.J = zeros(length(tout),' num2str(nx) ',' num2str(nx) ');\n']);
    fprintf(fid,['sol.root = NaN(options_cvode.nmaxroot,' num2str(nr) ');\n']);
    fprintf(fid,['sol.rootval = NaN(options_cvode.nmaxroot,' num2str(nr) ');\n']);
    fprintf(fid,['sol.numsteps = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numrhsevals = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numlinsolvsetups = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numerrtestfails = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.order = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numnonlinsolviters = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numjacevals = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numliniters = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numconvfails = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numprecevals = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numprecsolves = zeros(length(tout),1);\n\n']);
    fprintf(fid,['sol.numjtimesevals = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numstepsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numrhsevalsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numlinsolvsetupsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numerrtestfailsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.orderS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numnonlinsolvitersS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numjacevalsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numlinitersS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numconvfailsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numprecevalsS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numprecsolvesS = zeros(length(tout),1);\n']);
    fprintf(fid,['sol.numjtimesevalsS = zeros(length(tout),1);\n']);
    fprintf(fid,'\n');
    fprintf(fid,'plist = options_cvode.sens_ind-1;\n');
    fprintf(fid,'pbar = abs(theta);\n');
    fprintf(fid,'pbar(pbar==0) = 1;\n');
    fprintf(fid,'xscale = [];\n');
    
    fprintf(fid,['if(nargin>=5)\n']);
    fprintf(fid,['    options_cvode = setdefault(varargin{5},options_cvode);\n']);
    fprintf(fid,['else\n']);
    fprintf(fid,['end\n']);
    
    fprintf(fid,'if(options_cvode.sensi>0)\n');
    fprintf(fid,['    sol.llhS = zeros(length(options_cvode.sens_ind),1);\n']);
    fprintf(fid,'end\n');
    
    fprintf(fid,['if(max(options_cvode.sens_ind)>' num2str(np) ')\n']);
    fprintf(fid,['    error(''Sensitivity index exceeds parameter dimension!'')\n']);
    fprintf(fid,['end\n']);

    fprintf(fid,[ filename '(sol,tout,theta(1:' num2str(np) '),kappa(1:' num2str(nk) '),data,options_cvode,plist,pbar,xscale);\n']);
    fprintf(fid,['rt = [' num2str(struct.rt) '];\n']);
    fprintf(fid,['sol.x = sol.x(:,rt);\n']);
    fprintf(fid,['sol.xdot = sol.xdot(:,rt);\n']);
    fprintf(fid,'if(options_cvode.sensi>0)\n');
    if(isfield(struct,'param'))
        switch(struct.param)
            case 'log'
                fprintf(fid,['    sol.sllh = sol.llhS.*theta(options_cvode.sens_ind);\n']);
            case 'log10'
                fprintf(fid,['    sol.sllh = sol.llhS.*theta(options_cvode.sens_ind)*log(10);\n']);
            case 'lin'
                fprintf(fid,['    sol.sllh = sol.llhS;\n']);
            otherwise
                fprintf(fid,['    sol.sllh = sol.llhS;\n']);
        end
    else
        fprintf(fid,['    sol.sllh = sol.llhS(:);\n']);
    end
    fprintf(fid,'end\n');

    fprintf(fid,'old_status = sol.status;\n');
    fprintf(fid,'old_t = sol.t;\n');
    fprintf(fid,'old_x = sol.x;\n');
    fprintf(fid,'old_y = sol.y;\n');
    fprintf(fid,'old_theta = theta;\n');
    fprintf(fid,'old_kappa = kappa;\n');
    fprintf(fid,'old_tout = tout;\n');
    fprintf(fid,'old_nargout = nargout;\n');

    fclose(fid);
    addpath([odewrap_path 'models/' filename '/'])
end

